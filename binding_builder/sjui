#!/usr/bin/env bash

# SJUI Command-line Tool
# Usage: sjui <command> [args...]

if [ $# -eq 0 ]; then
    echo "Usage: sjui [--project <project_name>] [--environment <env>] <command> [subcommand] [args...]"
    echo ""
    echo "Options:"
    echo "  --project <name>      Specify project name when multiple .xcodeproj exist"
    echo "  --environment, -e <env>  Use environment-specific config (merges with base config.json)"
    echo ""
    echo "Available commands:"
    echo "  init [env1 env2 ...]  Initialize config.json file (optionally with environments)"
    echo "  setup                 Create directories and add them to Xcode project"
    echo "  g view <view_name> [--root]    Generate view controller and layout files"
    echo "  generate view <name> [--root]  Generate view controller and layout files (alias for g)"
    echo "  g collection <ViewFolder>/<CellName>    Generate collection view cell"
    echo "  generate collection <ViewFolder>/<CellName>    Generate collection view cell (alias for g)"
    echo "  g partial <partial_name>           Generate partial JSON layout"
    echo "  generate partial <partial_name>   Generate partial JSON layout (alias for g)"
    echo "  d view <view_name>    Destroy view controller and layout files"
    echo "  destroy view <name>   Destroy view controller and layout files (alias for d)"
    echo "  b                     Build binding files from JSON layouts"
    echo "  build                 Build binding files from JSON layouts (alias for b)"
    echo "  hotload <command>     Manage HotLoader IP monitoring"
    echo ""
    echo ""
    echo "HotLoad commands:"
    echo "  hotload listen        Start HotLoad server and IP monitor (full development environment)"
    echo "  hotload start         Start IP monitor (foreground)"
    echo "  hotload daemon        Start IP monitor (background)"
    echo "  hotload stop          Stop HotLoad server and IP monitor"
    echo "  hotload status        Show IP monitor status"
    echo "  hotload update        Force update Info.plist with current IP"
    echo ""
    echo "Examples:"
    echo "  sjui init"
    echo "  sjui init dev staging production"
    echo "  sjui setup"
    echo "  sjui g view sample"
    echo "  sjui generate view sample"
    echo "  sjui d view sample"
    echo "  sjui destroy view sample"
    echo "  sjui b"
    echo "  sjui build"
    echo "  sjui hotload listen"
    echo "  sjui hotload daemon"
    echo "  sjui hotload status"
    echo "  sjui hotload stop"
    echo ""
    echo "  sjui --project MyProject g view sample"
    echo "  sjui --project AnotherApp build"
    echo "  sjui --environment dev build"
    echo "  sjui -e production g view sample"
    exit 1
fi

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMMANDS_DIR="$SCRIPT_DIR/commands"

# Source all command files
source "$COMMANDS_DIR/init_command.sh"
source "$COMMANDS_DIR/setup_command.sh"
source "$COMMANDS_DIR/generate_command.sh"
source "$COMMANDS_DIR/destroy_command.sh"
source "$COMMANDS_DIR/build_command.sh"
source "$COMMANDS_DIR/hotload_command.sh"

# Parse options
PROJECT_NAME=""
ENVIRONMENT=""
while [[ $# -gt 0 ]]; do
    case $1 in
        --project)
            PROJECT_NAME="$2"
            shift 2
            ;;
        --environment|-e)
            ENVIRONMENT="$2"
            shift 2
            ;;
        *)
            break
            ;;
    esac
done

# Export environment for use in Ruby scripts
export SJUI_ENVIRONMENT="$ENVIRONMENT"

# Create a temporary Ruby script to find project file
PROJECT_FINDER_SCRIPT=$(cat << EOF
require '$SCRIPT_DIR/project_finder'
require 'json'

begin
  project_name = ARGV[1] # プロジェクト名（オプション）
  search_dir = ARGV[0] || Dir.pwd
  config_file = File.join(search_dir, 'config.json')
  
  # Try to read config.json if no project name specified
  if (!project_name || project_name.empty?) && File.exist?(config_file)
    begin
      config = JSON.parse(File.read(config_file))
      stored_project_name = config['project_file_name']
      
      # Use stored project name if it exists
      if stored_project_name && !stored_project_name.empty?
        project_file = ProjectFinder.find_project_file_by_name(search_dir, stored_project_name)
        puts project_file
        exit 0
      end
    rescue JSON::ParserError
      # Ignore JSON parsing errors and fallback to normal search
    end
  end
  
  # Fallback to normal project finding logic
  if project_name && !project_name.empty?
    project_file = ProjectFinder.find_project_file_by_name(search_dir, project_name)
  else
    project_file = ProjectFinder.find_project_file(search_dir)
  end
  puts project_file
rescue => e
  STDERR.puts "Error: #{e.message}"
  exit 1
end
EOF
)

# Find project file
PROJECT_FILE=$(echo "$PROJECT_FINDER_SCRIPT" | ruby - "$SCRIPT_DIR" "$PROJECT_NAME")
if [ $? -ne 0 ]; then
    echo "Failed to find Xcode project file"
    exit 1
fi

# Ensure we have the .xcodeproj directory, not the .pbxproj file
if [[ "$PROJECT_FILE" == *"project.pbxproj" ]]; then
    PROJECT_FILE=$(dirname "$PROJECT_FILE")
fi

COMMAND="$1"
shift

# Execute command
case "$COMMAND" in
    "init")
        init_command "$SCRIPT_DIR" "$PROJECT_FINDER_SCRIPT" "$@"
        ;;
    "setup")
        setup_command "$SCRIPT_DIR" "$PROJECT_FILE"
        ;;
    "g"|"generate")
        generate_command "$SCRIPT_DIR" "$PROJECT_FILE" "$@"
        ;;
    "d"|"destroy")
        destroy_command "$SCRIPT_DIR" "$PROJECT_FILE" "$@"
        ;;
    "b"|"build")
        build_command "$SCRIPT_DIR" "$PROJECT_FILE"
        ;;
    "hotload")
        hotload_command "$SCRIPT_DIR" "$PROJECT_FILE" "$@"
        ;;
    *)
        echo "Unknown command: $COMMAND"
        echo "Run 'sjui' without arguments to see available commands"
        exit 1
        ;;
esac